#!/usr/bin/env swift

import Foundation

let referenceCoverage = "coverage.txt"

struct CoverageReport: Codable {
    let lines: Int
    let coverage: Double
    let targets: [Target]
    
    private enum CodingKeys: String, CodingKey {
        case lines = "coveredLines"
        case coverage = "lineCoverage"
        case targets = "targets"
    }
}

struct Target: Codable {
    let name: String
    let lines: Int
    let coverage: Double
    
    private enum CodingKeys: String, CodingKey {
        case lines = "coveredLines"
        case coverage = "lineCoverage"
        case name = "name"
    }
}

let arguments = CommandLine.arguments

guard arguments.count == 2 else {
    print("Incorrect parameters. Include JSON file generated by \"xcrun xccov view --report --json <tests.xcresult> \"")
    print("Usage: <script> file.JSON <optional parameter> terse")
    exit(0)
}

let file = CommandLine.arguments[1]
let currentDirectoryPath = FileManager.default.currentDirectoryPath
let filePath = currentDirectoryPath + "/" + file

guard let json = try? String(contentsOfFile: filePath, encoding: .utf8), let data = json.data(using: .utf8) else {
    print("Error: Invalid JSON")
    exit(0)
}
guard let report = try? JSONDecoder().decode(CoverageReport.self, from: data) else {
    print("Error: Could not decode the report.")
    exit(0)
}

let referenceFilePath = referenceCoverage

guard let referenceCoverageData = try? String(contentsOfFile: referenceFilePath, encoding: .utf8)  else {
    print("Error: Invalid coverage reference file: \(referenceFilePath)")
    exit(0)
}

let coverageReferenceValues = referenceCoverageData.split(whereSeparator: \.isNewline)

let decimalFormatter = NumberFormatter()
decimalFormatter.numberStyle = .decimal
decimalFormatter.minimumFractionDigits = 2
decimalFormatter.maximumFractionDigits = 2

var result = true

let changedFeatures = shell("bash ./scripts/filterSourceChanges.sh")
let trimmedFeatures = changedFeatures.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines)

if trimmedFeatures.isEmpty {
    print("No source code has changed. Skipping coverage check.")
    exit(0)
}

// Convert string to an array, and remove duplicates
let allFeatureModules = Array(Set(trimmedFeatures.components(separatedBy: " ")))

print("Feature modules that have changed: \(allFeatureModules)")

for target in report.targets {
    let coveragePercent = roundDouble(input: target.coverage * 100.0)
    
    // find the value in the reference file
    for line in coverageReferenceValues {
        if line.contains(target.name) && targetHasChanged(target: target.name, featureChanges: allFeatureModules) {
            let referenceCoverageInModuleString = (line.components(separatedBy: [" "]))[1]
            if let referenceCoverageInModule = Double(referenceCoverageInModuleString) {
                if coveragePercent >= referenceCoverageInModule {
                    print("\(target.name) Coverage OK")
                } else {
                    result = false
                    print("Error: \(target.name) Coverage \(coveragePercent) is lower than reference: \(referenceCoverageInModule)")
                }
            }
        }
    }
}

print("Coverage check: \(result == true ? "Pass" : "Fail")")

if result == false {
    exit(1)
}

func roundDouble(input: Double) -> Double {
    let printableCoverage = decimalFormatter.string(from: NSNumber(value: input)) ?? "0.0"
    return Double(printableCoverage) ?? 0.0
}

func shell(_ command: String) -> String {
    let task = Process()
    let pipe = Pipe()
    
    task.standardOutput = pipe
    task.standardError = pipe
    task.arguments = ["-c", command]
    task.launchPath = "/bin/zsh"
    task.standardInput = nil
    task.launch()
    
    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: .utf8)!
    
    return output
}

func targetHasChanged(target: String, featureChanges: [String]) -> Bool {
    var matching = false
    
    for value in featureChanges {
        if (value + ".framework") == target {
            matching = true
            break
        }
    }
    
    return matching
}
